{"version":3,"file":"index-esm.min.js","sources":["../lib/Polynomial.js","../lib/SqrtPolynomial.js"],"sourcesContent":["/* eslint-disable camelcase, unicorn/prefer-type-error */\n\n/**\n *   Polynomial\n *\n *   @copyright 2002, 2013 Kevin Lindsey\n *\n *   contribution {@link http://github.com/Quazistax/kld-polynomial}\n *       @copyright 2015 Robert Benko (Quazistax) <quazistax@gmail.com>\n *       @license MIT\n */\n\nPolynomial.TOLERANCE = 1e-6;\nPolynomial.ACCURACY = 15;\n\n\n/**\n *  interpolate\n *\n *  Based on poloint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n *\n *  @param {Array<number>} xs\n *  @param {Array<number>} ys\n *  @param {number} n\n *  @param {number} offset\n *  @param {number} x\n *\n *  @returns {{y: number, dy: number}}\n */\nPolynomial.interpolate = function(xs, ys, n, offset, x) {\n    if (xs.constructor !== Array || ys.constructor !== Array) {\n        throw new Error(\"Polynomial.interpolate: xs and ys must be arrays\");\n    }\n    if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n        throw new Error(\"Polynomial.interpolate: n, offset, and x must be numbers\");\n    }\n\n    let i;\n    let y = 0;\n    let dy = 0;\n    const c = new Array(n);\n    const d = new Array(n);\n    let ns = 0;\n\n    let diff = Math.abs(x - xs[offset]);\n\n    for (i = 0; i < n; i++) {\n        const dift = Math.abs(x - xs[offset + i]);\n\n        if (dift < diff) {\n            ns = i;\n            diff = dift;\n        }\n        c[i] = d[i] = ys[offset + i];\n    }\n\n    y = ys[offset + ns];\n    ns--;\n\n    for (let m = 1; m < n; m++) {\n        for (i = 0; i < n - m; i++) {\n            const ho = xs[offset + i] - x;\n            const hp = xs[offset + i + m] - x;\n            const w = c[i + 1] - d[i];\n            let den = ho - hp;\n\n            if (den === 0.0) {\n                throw new Error(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n            }\n\n            den = w / den;\n            d[i] = hp * den;\n            c[i] = ho * den;\n        }\n\n        dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n        y += dy;\n    }\n\n    return {y, dy};\n};\n\n\n/**\n *  Polynomial\n *\n *  @class\n *  @param {Array<number>} args\n *  @returns {Polynomial}\n */\nfunction Polynomial(...args) {\n    this.init(args);\n}\n\n\n/**\n *  init\n *\n *  @param {Array<number>} coefs\n */\nPolynomial.prototype.init = function(coefs) {\n    this.coefs = [];\n\n    for (let i = coefs.length - 1; i >= 0; i--) {\n        this.coefs.push(coefs[i]);\n    }\n\n    this._variable = \"t\";\n    this._s = 0;\n};\n\n\n/**\n *  eval\n *\n *  @param {number} x\n */\nPolynomial.prototype.eval = function(x) {\n    if (isNaN(x)) {\n        throw new Error(\"Polynomial.eval: parameter must be a number\");\n    }\n\n    let result = 0;\n\n    for (let i = this.coefs.length - 1; i >= 0; i--) {\n        result = result * x + this.coefs[i];\n    }\n\n    return result;\n};\n\n\n/**\n *  add\n *\n *  @param {Polynomial} that\n *  @returns {Polynomial}\n */\nPolynomial.prototype.add = function(that) {\n    const result = new Polynomial();\n    const d1 = this.getDegree();\n    const d2 = that.getDegree();\n    const dmax = Math.max(d1, d2);\n\n    for (let i = 0; i <= dmax; i++) {\n        const v1 = (i <= d1) ? this.coefs[i] : 0;\n        const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n        result.coefs[i] = v1 + v2;\n    }\n\n    return result;\n};\n\n\n/**\n *  multiply\n *\n *  @param {Polynomial} that\n *  @returns {Polynomial}\n */\nPolynomial.prototype.multiply = function(that) {\n    const result = new Polynomial();\n\n    for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n        result.coefs.push(0);\n    }\n\n    for (let i = 0; i <= this.getDegree(); i++) {\n        for (let j = 0; j <= that.getDegree(); j++) {\n            result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n        }\n    }\n\n    return result;\n};\n\n\n/**\n *  divide_scalar\n *\n *  @param {number} scalar\n */\nPolynomial.prototype.divide_scalar = function(scalar) {\n    for (let i = 0; i < this.coefs.length; i++) {\n        this.coefs[i] /= scalar;\n    }\n};\n\n\n/**\n *  simplify\n *\n *  @param {number} TOLERANCE\n */\nPolynomial.prototype.simplify = function(TOLERANCE) {\n    if (TOLERANCE === undefined) {\n        TOLERANCE = 1e-12;\n    }\n\n    for (let i = this.getDegree(); i >= 0; i--) {\n        if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n            this.coefs.pop();\n        }\n        else {\n            break;\n        }\n    }\n};\n\n\n/**\n *  bisection\n *\n *  @param {number} min\n *  @param {number} max\n *\n *  @returns {number}\n */\nPolynomial.prototype.bisection = function(min, max) {\n    let minValue = this.eval(min);\n    let maxValue = this.eval(max);\n    let result;\n\n    if (Math.abs(minValue) <= Polynomial.TOLERANCE) {\n        result = min;\n    }\n    else if (Math.abs(maxValue) <= Polynomial.TOLERANCE) {\n        result = max;\n    }\n    else if (minValue * maxValue <= 0) {\n        const tmp1 = Math.log(max - min);\n        const tmp2 = Math.LN10 * Polynomial.ACCURACY;\n        const iters = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n        for (let i = 0; i < iters; i++) {\n            result = 0.5 * (min + max);\n            const value = this.eval(result);\n\n            if (Math.abs(value) <= Polynomial.TOLERANCE) {\n                break;\n            }\n\n            if (value * minValue < 0) {\n                max = result;\n                maxValue = value;\n            }\n            else {\n                min = result;\n                minValue = value;\n            }\n        }\n    }\n\n    return result;\n};\n\n\n/**\n *  toString\n *\n *  @returns {string}\n */\nPolynomial.prototype.toString = function() {\n    const coefs = [];\n    const signs = [];\n\n    for (let i = this.coefs.length - 1; i >= 0; i--) {\n        let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n        if (value !== 0) {\n            const signString = (value < 0) ? \" - \" : \" + \";\n\n            value = Math.abs(value);\n\n            if (i > 0) {\n                if (value === 1) {\n                    value = this._variable;\n                }\n                else {\n                    value += this._variable;\n                }\n            }\n\n            if (i > 1) {\n                value += \"^\" + i;\n            }\n\n            signs.push(signString);\n            coefs.push(value);\n        }\n    }\n\n    signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n    let result = \"\";\n\n    for (let i = 0; i < coefs.length; i++) {\n        result += signs[i] + coefs[i];\n    }\n\n    return result;\n};\n\n\n/**\n *  trapezoid\n *\n *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n *\n *  @param {number} min\n *  @param {number} max\n *  @param {number} n\n *  @returns {number}\n */\nPolynomial.prototype.trapezoid = function(min, max, n) {\n    if (isNaN(min) || isNaN(max) || isNaN(n)) {\n        throw new Error(\"Polynomial.trapezoid: parameters must be numbers\");\n    }\n\n    const range = max - min;\n\n    if (n === 1) {\n        const minValue = this.eval(min);\n        const maxValue = this.eval(max);\n\n        this._s = 0.5 * range * (minValue + maxValue);\n    }\n    else {\n        const iter = 1 << (n - 2);\n        const delta = range / iter;\n        let x = min + 0.5 * delta;\n        let sum = 0;\n\n        for (let i = 0; i < iter; i++) {\n            sum += this.eval(x);\n            x += delta;\n        }\n\n        this._s = 0.5 * (this._s + range * sum / iter);\n    }\n\n    if (isNaN(this._s)) {\n        throw new Error(\"Polynomial.trapezoid: this._s is NaN\");\n    }\n\n    return this._s;\n};\n\n\n/**\n *  simpson\n *\n *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n *\n *  @param {number} min\n *  @param {number} max\n *  @returns {number}\n */\nPolynomial.prototype.simpson = function(min, max) {\n    if (isNaN(min) || isNaN(max)) {\n        throw new Error(\"Polynomial.simpson: parameters must be numbers\");\n    }\n\n    const range = max - min;\n    let st = 0.5 * range * (this.eval(min) + this.eval(max));\n    let t = st;\n    let s = 4.0 * st / 3.0;\n    let os = s;\n    let ost = st;\n    const TOLERANCE = 1e-7;\n\n    let iter = 1;\n\n    for (let n = 2; n <= 20; n++) {\n        const delta = range / iter;\n        let x = min + 0.5 * delta;\n        let sum = 0;\n\n        for (let i = 1; i <= iter; i++) {\n            sum += this.eval(x);\n            x += delta;\n        }\n\n        t = 0.5 * (t + range * sum / iter);\n        st = t;\n        s = (4.0 * st - ost) / 3.0;\n\n        if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n            break;\n        }\n\n        os = s;\n        ost = st;\n        iter <<= 1;\n    }\n\n    return s;\n};\n\n\n/**\n *  romberg\n *\n *  @param {number} min\n *  @param {number} max\n *  @returns {number}\n */\nPolynomial.prototype.romberg = function(min, max) {\n    if (isNaN(min) || isNaN(max)) {\n        throw new Error(\"Polynomial.romberg: parameters must be numbers\");\n    }\n\n    const MAX = 20;\n    const K = 3;\n    const TOLERANCE = 1e-6;\n    const s = new Array(MAX + 1);\n    const h = new Array(MAX + 1);\n    let result = {y: 0, dy: 0};\n\n    h[0] = 1.0;\n\n    for (let j = 1; j <= MAX; j++) {\n        s[j - 1] = this.trapezoid(min, max, j);\n\n        if (j >= K) {\n            result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n            if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                break;\n            }\n        }\n\n        s[j] = s[j - 1];\n        h[j] = 0.25 * h[j - 1];\n    }\n\n    return result.y;\n};\n\n// getters and setters\n\n/**\n *  get degree\n *\n *  @returns {number}\n */\nPolynomial.prototype.getDegree = function() {\n    return this.coefs.length - 1;\n};\n\n\n/**\n *  getDerivative\n *\n *  @returns {Polynomial}\n */\nPolynomial.prototype.getDerivative = function() {\n    const derivative = new Polynomial();\n\n    for (let i = 1; i < this.coefs.length; i++) {\n        derivative.coefs.push(i * this.coefs[i]);\n    }\n\n    return derivative;\n};\n\n\n/**\n *  getRoots\n *\n *  @returns {Array<number>}\n */\nPolynomial.prototype.getRoots = function() {\n    let result;\n\n    this.simplify();\n\n    switch (this.getDegree()) {\n        case 0: result = []; break;\n        case 1: result = this.getLinearRoot(); break;\n        case 2: result = this.getQuadraticRoots(); break;\n        case 3: result = this.getCubicRoots(); break;\n        case 4: result = this.getQuarticRoots(); break;\n        default:\n            result = [];\n    }\n\n    return result;\n};\n\n\n/**\n *  getRootsInInterval\n *\n *  @param {number} min\n *  @param {number} max\n *  @returns {Array<number>}\n */\nPolynomial.prototype.getRootsInInterval = function(min, max) {\n    const roots = [];\n\n    /**\n     *  @param {number} value\n     */\n    function push(value) {\n        if (value !== null) {\n            roots.push(value);\n        }\n    }\n\n    if (this.getDegree() === 1) {\n        push(this.bisection(min, max));\n    }\n    else {\n        // get roots of derivative\n        const deriv = this.getDerivative();\n        const droots = deriv.getRootsInInterval(min, max);\n\n        if (droots.length > 0) {\n            // find root on [min, droots[0]]\n            push(this.bisection(min, droots[0]));\n\n            // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n            for (let i = 0; i <= droots.length - 2; i++) {\n                push(this.bisection(droots[i], droots[i + 1]));\n            }\n\n            // find root on [droots[count-1],xmax]\n            push(this.bisection(droots[droots.length - 1], max));\n        }\n        else {\n            // polynomial is monotone on [min,max], has at most one root\n            push(this.bisection(min, max));\n        }\n    }\n\n    return roots;\n};\n\n\n/**\n *  getLinearRoot\n *\n *  @returns {number}\n */\nPolynomial.prototype.getLinearRoot = function() {\n    const result = [];\n    const a = this.coefs[1];\n\n    if (a !== 0) {\n        result.push(-this.coefs[0] / a);\n    }\n\n    return result;\n};\n\n\n/**\n *  getQuadraticRoots\n *\n *  @returns {Array<number>}\n */\nPolynomial.prototype.getQuadraticRoots = function() {\n    const results = [];\n\n    if (this.getDegree() === 2) {\n        const a = this.coefs[2];\n        const b = this.coefs[1] / a;\n        const c = this.coefs[0] / a;\n        const d = b * b - 4 * c;\n\n        if (d > 0) {\n            const e = Math.sqrt(d);\n\n            results.push(0.5 * (-b + e));\n            results.push(0.5 * (-b - e));\n        }\n        else if (d === 0) {\n            // really two roots with same value, but we only return one\n            results.push(0.5 * -b);\n        }\n    }\n\n    return results;\n};\n\n\n/**\n *  getCubicRoots\n *\n *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n *  code along with many other excellent examples are avaiable at his site:\n *  http://www.geometrictools.com\n *\n *  @returns {Array<number>}\n */\nPolynomial.prototype.getCubicRoots = function() {\n    const results = [];\n\n    if (this.getDegree() === 3) {\n        const c3 = this.coefs[3];\n        const c2 = this.coefs[2] / c3;\n        const c1 = this.coefs[1] / c3;\n        const c0 = this.coefs[0] / c3;\n\n        const a = (3 * c1 - c2 * c2) / 3;\n        const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n        const offset = c2 / 3;\n        let discrim = b * b / 4 + a * a * a / 27;\n        const halfB = b / 2;\n\n        const ZEROepsilon = this.zeroErrorEstimate();\n\n        if (Math.abs(discrim) <= ZEROepsilon) {\n            discrim = 0;\n        }\n\n        if (discrim > 0) {\n            const e = Math.sqrt(discrim);\n            let root; // eslint-disable-line no-shadow\n\n            let tmp = -halfB + e;\n\n            if (tmp >= 0) {\n                root = Math.pow(tmp, 1 / 3);\n            }\n            else {\n                root = -Math.pow(-tmp, 1 / 3);\n            }\n\n            tmp = -halfB - e;\n\n            if (tmp >= 0) {\n                root += Math.pow(tmp, 1 / 3);\n            }\n            else {\n                root -= Math.pow(-tmp, 1 / 3);\n            }\n\n            results.push(root - offset);\n        }\n        else if (discrim < 0) {\n            const distance = Math.sqrt(-a / 3);\n            const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n            const cos = Math.cos(angle);\n            const sin = Math.sin(angle);\n            const sqrt3 = Math.sqrt(3);\n\n            results.push(2 * distance * cos - offset);\n            results.push(-distance * (cos + sqrt3 * sin) - offset);\n            results.push(-distance * (cos - sqrt3 * sin) - offset);\n        }\n        else {\n            let tmp;\n\n            if (halfB >= 0) {\n                tmp = -Math.pow(halfB, 1 / 3);\n            }\n            else {\n                tmp = Math.pow(-halfB, 1 / 3);\n            }\n\n            results.push(2 * tmp - offset);\n            // really should return next root twice, but we return only one\n            results.push(-tmp - offset);\n        }\n    }\n\n    return results;\n};\n\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n\n/**\n *  Calculates roots of quartic polynomial. <br/>\n *  First, derivative roots are found, then used to split quartic polynomial\n *  into segments, each containing one root of quartic polynomial.\n *  Segments are then passed to newton's method to find roots.\n *\n *  @returns {Array<number>} roots\n */\nPolynomial.prototype.getQuarticRoots = function() {\n    let results = [];\n    const n = this.getDegree();\n\n    if (n === 4) {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n        poly.divide_scalar(poly.coefs[n]);\n\n        const ERRF = 1e-15;\n\n        if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n            poly.coefs[0] = 0;\n        }\n\n        const poly_d = poly.getDerivative();\n        const derrt = poly_d.getRoots().sort((a, b) => a - b);\n        const dery = [];\n        const nr = derrt.length - 1;\n        const rb = this.bounds();\n\n        const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n        for (let i = 0; i <= nr; i++) {\n            dery.push(poly.eval(derrt[i]));\n        }\n\n        for (let i = 0; i <= nr; i++) {\n            if (Math.abs(dery[i]) < ZEROepsilon) {\n                dery[i] = 0;\n            }\n        }\n\n        let i = 0;\n        const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n        const guesses = [];\n        const minmax = [];\n\n        if (nr > -1) {\n            if (dery[0] !== 0) {\n                if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                    guesses.push(derrt[0] - dx);\n                    minmax.push([rb.minX, derrt[0]]);\n                }\n            }\n            else {\n                results.push(derrt[0], derrt[0]);\n                i++;\n            }\n\n            for (; i < nr; i++) {\n                if (dery[i + 1] === 0) {\n                    results.push(derrt[i + 1], derrt[i + 1]);\n                    i++;\n                }\n                else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                    guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                    minmax.push([derrt[i], derrt[i + 1]]);\n                }\n            }\n            if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                guesses.push(derrt[nr] + dx);\n                minmax.push([derrt[nr], rb.maxX]);\n            }\n        }\n\n        /**\n         *  @param {number} x\n         *  @returns {number}\n         */\n        const f = function(x) {\n            return poly.eval(x);\n        };\n\n        /**\n         *  @param {number} x\n         *  @returns {number}\n         */\n        const df = function(x) {\n            return poly_d.eval(x);\n        };\n\n        if (guesses.length > 0) {\n            for (i = 0; i < guesses.length; i++) {\n                guesses[i] = Polynomial.newton_secant_bisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n            }\n        }\n\n        results = results.concat(guesses);\n    }\n\n    return results;\n};\n\n\n/**\n *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n *\n *  @param {number} maxabsX\n *  @returns {number}\n */\nPolynomial.prototype.zeroErrorEstimate = function(maxabsX) {\n    const poly = this;\n    const ERRF = 1e-15;\n\n    if (typeof maxabsX === \"undefined\") {\n        const rb = poly.bounds();\n\n        maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n    }\n\n    if (maxabsX < 0.001) {\n        return 2 * Math.abs(poly.eval(ERRF));\n    }\n\n    const n = poly.coefs.length - 1;\n    const an = poly.coefs[n];\n\n    return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n        const nm = v / an * Math.pow(maxabsX, i);\n        return nm > m ? nm : m;\n    }, 0);\n};\n\n\n/**\n *  Calculates upper Real roots bounds. <br/>\n *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n *\n *  @returns {{ negX: number, posX: number }}\n */\nPolynomial.prototype.bounds_UpperReal_Fujiwara = function() {\n    let a = this.coefs;\n    const n = a.length - 1;\n    const an = a[n];\n\n    if (an !== 1) {\n        a = this.coefs.map(v => v / an);\n    }\n\n    const b = a.map((v, i) => {\n        return (i < n)\n            ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n            : v;\n    });\n\n    let coefSelectionFunc;\n    const find2Max = function(acc, bi, i) {\n        if (coefSelectionFunc(i)) {\n            if (acc.max < bi) {\n                acc.nearmax = acc.max;\n                acc.max = bi;\n            }\n            else if (acc.nearmax < bi) {\n                acc.nearmax = bi;\n            }\n        }\n        return acc;\n    };\n\n    coefSelectionFunc = function(i) {\n        return i < n && a[i] < 0;\n    };\n\n    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n    const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n    coefSelectionFunc = function(i) {\n        return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n    };\n\n    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n    const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n    return {\n        negX: -2 * max_nearmax_neg.max,\n        posX: 2 * max_nearmax_pos.max\n    };\n};\n\n\n/**\n *  Calculates lower Real roots bounds. <br/>\n *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n *\n *  @returns {{ negX: number, posX: number }}\n */\nPolynomial.prototype.bounds_LowerReal_Fujiwara = function() {\n    const poly = new Polynomial();\n\n    poly.coefs = this.coefs.slice().reverse();\n\n    const res = poly.bounds_UpperReal_Fujiwara();\n\n    res.negX = 1 / res.negX;\n    res.posX = 1 / res.posX;\n\n    return res;\n};\n\n\n/**\n *  Calculates left and right Real roots bounds. <br/>\n *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n *\n *  @returns {{ minX: number, maxX: number }}\n*/\nPolynomial.prototype.bounds = function() {\n    const urb = this.bounds_UpperReal_Fujiwara();\n    const rb = {minX: urb.negX, maxX: urb.posX};\n\n    if (urb.negX === 0 && urb.posX === 0) {\n        return rb;\n    }\n\n    if (urb.negX === 0) {\n        rb.minX = this.bounds_LowerReal_Fujiwara().posX;\n    }\n    else if (urb.posX === 0) {\n        rb.maxX = this.bounds_LowerReal_Fujiwara().negX;\n    }\n\n    if (rb.minX > rb.maxX) {\n        rb.minX = rb.maxX = 0;\n    }\n\n    return rb;\n    // TODO: if sure that there are no complex roots\n    // (maybe by using Sturm's theorem) use:\n    // return this.bounds_Real_Laguerre();\n};\n\n\n/**\n *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n *  When using bounds, algorithm falls back to secant if newton goes out of range.\n *  Bisection is fallback for secant when determined secant is not efficient enough.\n *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n *\n *  @param {number} x0 - Inital root guess\n *  @param {Function} f - Function which root we are trying to find\n *  @param {Function} df - Derivative of function f\n *  @param {number} max_iterations - Maximum number of algorithm iterations\n *  @param {number} [min] - Left bound value\n *  @param {number} [max] - Right bound value\n *  @returns {number} root\n */\nPolynomial.newton_secant_bisection = function(x0, f, df, max_iterations, min, max) {\n    let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n    let y, y_atmin, y_atmax;\n\n    x = x0;\n\n    const ACCURACY = 14;\n    const min_correction_factor = Math.pow(10, -ACCURACY);\n    const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n    if (isBounded) {\n        if (min > max) {\n            throw new Error(\"newton root finding: min must be greater than max\");\n        }\n\n        y_atmin = f(min);\n        y_atmax = f(max);\n\n        if (sign(y_atmin) === sign(y_atmax)) {\n            throw new Error(\"newton root finding: y values of bounds must be of opposite sign\");\n        }\n    }\n\n    const isEnoughCorrection = function() {\n        // stop if correction is too small or if correction is in simple loop\n        return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n            (prev_x_ef_correction === (x - x_correction) - x);\n    };\n\n\n    for (let i = 0; i < max_iterations; i++) {\n        dfx = df(x);\n\n        if (dfx === 0) {\n            if (prev_dfx === 0) {\n                // error\n                throw new Error(\"newton root finding: df(x) is zero\");\n            }\n            else {\n                // use previous derivation value\n                dfx = prev_dfx;\n            }\n            // or move x a little?\n            // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n        }\n\n        prev_dfx = dfx;\n        y = f(x);\n        x_correction = y / dfx;\n        x_new = x - x_correction;\n\n        if (isEnoughCorrection()) {\n            break;\n        }\n\n        if (isBounded) {\n            if (sign(y) === sign(y_atmax)) {\n                max = x;\n                y_atmax = y;\n            }\n            else if (sign(y) === sign(y_atmin)) {\n                min = x;\n                y_atmin = y;\n            }\n            else {\n                x = x_new;\n                break;\n            }\n\n            if ((x_new < min) || (x_new > max)) {\n                if (sign(y_atmin) === sign(y_atmax)) {\n                    break;\n                }\n\n                const RATIO_LIMIT = 50;\n                const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                const dy = y_atmax - y_atmin;\n                const dx = max - min;\n\n                if (dy === 0) {\n                    x_correction = x - (min + dx * 0.5);\n                }\n                else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                    x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                }\n                else {\n                    x_correction = x - (min - y_atmin / dy * dx);\n                }\n                x_new = x - x_correction;\n\n                if (isEnoughCorrection()) {\n                    break;\n                }\n            }\n        }\n\n        prev_x_ef_correction = x - x_new;\n        x = x_new;\n    }\n\n    return x;\n};\n\nexport default Polynomial;\n","/**\n *   SqrtPolynomial\n *\n *   copyright 2003, 2013 Kevin Lindsey\n */\n\nimport Polynomial from \"./Polynomial.js\";\n\n/**\n *   class variables\n */\nSqrtPolynomial.VERSION = 1.0;\n\n// setup inheritance\nSqrtPolynomial.prototype = new Polynomial();\nSqrtPolynomial.prototype.constructor = SqrtPolynomial;\nSqrtPolynomial.superclass = Polynomial.prototype;\n\n\n/**\n *  SqrtPolynomial\n *\n *  @class\n *  @param {Array<Object>} args\n */\nfunction SqrtPolynomial(...args) {\n    this.init(args);\n}\n\n\n/**\n *  eval\n *\n *  @param {number} x\n *  @returns {number}\n */\nSqrtPolynomial.prototype.eval = function(x) {\n    const TOLERANCE = 1e-7;\n    let result = SqrtPolynomial.superclass.eval.call(this, x);\n\n    // NOTE: May need to change the following.  I added these to capture\n    // some really small negative values that were being generated by one\n    // of my Bezier arcLength functions\n    if (Math.abs(result) < TOLERANCE) {\n        result = 0;\n    }\n\n    if (result < 0) {\n        throw new Error(\"SqrtPolynomial.eval: cannot take square root of negative number\");\n    }\n\n    return Math.sqrt(result);\n};\n\n/**\n *  toString\n *\n *  @returns {string}\n */\nSqrtPolynomial.prototype.toString = function() {\n    const result = SqrtPolynomial.superclass.toString.call(this);\n\n    return \"sqrt(\" + result + \")\";\n};\n\nexport default SqrtPolynomial;\n"],"names":["Polynomial","args","init","sign","x","NaN","SqrtPolynomial","TOLERANCE","ACCURACY","interpolate","xs","ys","n","offset","constructor","Array","Error","isNaN","i","y","dy","c","d","ns","diff","Math","abs","dift","m","ho","hp","w","den","prototype","coefs","length","push","_variable","_s","eval","result","this","add","that","d1","getDegree","d2","dmax","max","v1","v2","multiply","j","divide_scalar","scalar","simplify","undefined","pop","bisection","min","minValue","maxValue","tmp1","log","tmp2","LN10","iters","ceil","LN2","value","toString","signs","round","signString","trapezoid","range","iter","delta","sum","simpson","st","t","s","os","ost","romberg","MAX","h","getDerivative","derivative","getRoots","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","getRootsInInterval","roots","droots","a","results","b","e","sqrt","c3","c2","c1","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","pow","distance","angle","atan2","cos","sin","sqrt3","poly","slice","poly_d","derrt","sort","dery","nr","rb","bounds","maxabsX","minX","maxX","dx","guesses","minmax","f","df","newton_secant_bisection","concat","an","reduce","v","nm","bounds_UpperReal_Fujiwara","map","coefSelectionFunc","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","bounds_LowerReal_Fujiwara","reverse","res","urb","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","VERSION","superclass","call"],"mappings":"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"}