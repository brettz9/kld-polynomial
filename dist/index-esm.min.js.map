{"version":3,"file":"index-esm.min.js","sources":["../lib/Polynomial.js","../lib/SqrtPolynomial.js"],"sourcesContent":["/* eslint-disable camelcase, unicorn/prefer-type-error */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  Based on poloint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new Error(\"Polynomial.interpolate: xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new Error(\"Polynomial.interpolate: n, offset, and x must be numbers\");\n        }\n\n        let i;\n        let y = 0;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new Error(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Inital root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newton_secant_bisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new Error(\"newton root finding: min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new Error(\"newton root finding: y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new Error(\"newton root finding: df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new Error(`Polynomial.eval: parameter must be a number, got '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divide_scalar\n     *\n     *  @param {number} scalar\n     */\n    divide_scalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplify\n     *\n     *  @param {number} TOLERANCE\n     */\n    simplify(TOLERANCE = 1e-12) {\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    bisection(min, max) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= Polynomial.TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= Polynomial.TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * Polynomial.ACCURACY;\n            const iters = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < iters; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= Polynomial.TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new Error(\"Polynomial.trapezoid: parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new Error(\"Polynomial.trapezoid: this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.simpson: parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.romberg: parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplify();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new Error(\"Polynomial.getRootsInInterval: Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divide_scalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newton_secant_bisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxabsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxabsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxabsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxabsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxabsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_UpperReal_Fujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_LowerReal_Fujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.bounds_UpperReal_Fujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.bounds_UpperReal_Fujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.bounds_LowerReal_Fujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.bounds_LowerReal_Fujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.bounds_Real_Laguerre();\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_zeroSmallCoefs() {\n        const c = this.coefs;\n        const ERRF = 1e-15;\n        const err = 10 * ERRF * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_toMonic() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divide_scalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    bound_UpperAbs_Rouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    bound_LowerAbs_Rouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n\n    /**\n     *  Calculates left and right Real roots bounds.<br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    bounds_Real_Laguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRoots_Descartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n}\n\nPolynomial.TOLERANCE = 1e-6;\nPolynomial.ACCURACY = 15;\n\nexport default Polynomial;\n","/**\n *  SqrtPolynomial.js\n *\n *  @module SqrtPolynomial\n *  @copyright 2002-2019 Kevin Lindsey\n */\n\nimport Polynomial from \"./Polynomial.js\";\n\n\n/**\n *  SqrtPolynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass SqrtPolynomial extends Polynomial {\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     *  @returns {number}\n     */\n    eval(x) {\n        const TOLERANCE = 1e-7;\n\n        let result = super.eval(x);\n\n        // NOTE: May need to change the following.  I added these to capture\n        // some really small negative values that were being generated by one\n        // of my Bezier arcLength functions\n        if (Math.abs(result) < TOLERANCE) {\n            result = 0;\n        }\n\n        if (result < 0) {\n            throw new Error(\"SqrtPolynomial.eval: cannot take square root of negative number\");\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const result = super.toString();\n\n        return \"sqrt(\" + result + \")\";\n    }\n}\n\nexport default SqrtPolynomial;\n"],"names":["sign","x","NaN","Polynomial","coefs","i","arguments","length","push","_variable","_s","poly","this","slice","isNaN","Error","result","that","d1","getDegree","d2","dmax","Math","max","v1","v2","j","scalar","TOLERANCE","abs","pop","min","minValue","eval","maxValue","tmp1","log","tmp2","LN10","ACCURACY","iters","ceil","LN2","value","signs","round","signString","n","range","iter","delta","sum","st","t","s","os","ost","Array","MAX","h","y","dy","trapezoid","interpolate","derivative","simplify","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","roots","bisection","droots","getDerivative","getRootsInInterval","a","results","b","d","e","sqrt","c3","c2","c1","offset","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","pow","distance","angle","atan2","cos","sin","sqrt3","divide_scalar","poly_d","derrt","getRoots","sort","dery","nr","rb","bounds","maxabsX","minX","maxX","dx","guesses","minmax","f","df","newton_secant_bisection","concat","an","reduce","m","v","nm","map","coefSelectionFunc","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","reverse","res","bounds_UpperReal_Fujiwara","urb","bounds_LowerReal_Fujiwara","c","err","pv","cv","prev","curr","p1","undersqrt","p2","accum","ai","prev_a","pos","neg","maxRealPos","maxRealNeg","minComplex","xs","ys","constructor","ns","diff","dift","ho","hp","w","den","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","SqrtPolynomial"],"mappings":"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"}