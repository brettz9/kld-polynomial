{"version":3,"file":"index-esm.min.js","sources":["../lib/Polynomial.js","../lib/SqrtPolynomial.js"],"sourcesContent":["/* eslint-disable camelcase, unicorn/prefer-type-error */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  interpolate\n     *\n     *  Based on poloint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new Error(\"Polynomial.interpolate: xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new Error(\"Polynomial.interpolate: n, offset, and x must be numbers\");\n        }\n\n        let i;\n        let y = 0;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new Error(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Inital root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newton_secant_bisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new Error(\"newton root finding: min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new Error(\"newton root finding: y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new Error(\"newton root finding: df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new Error(`Polynomial.eval: parameter must be a number, got '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divide_scalar\n     *\n     *  @param {number} scalar\n     */\n    divide_scalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplify\n     *\n     *  @param {number} TOLERANCE\n     */\n    simplify(TOLERANCE) {\n        if (TOLERANCE === undefined) {\n            TOLERANCE = 1e-12;\n        }\n\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *\n     *  @returns {number}\n     */\n    bisection(min, max) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= Polynomial.TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= Polynomial.TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * Polynomial.ACCURACY;\n            const iters = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < iters; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= Polynomial.TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  trapezoid\n     *\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new Error(\"Polynomial.trapezoid: parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new Error(\"Polynomial.trapezoid: this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  simpson\n     *\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.simpson: parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.romberg: parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplify();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new Error(\"Polynomial.getRootsInInterval: Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divide_scalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newton_secant_bisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxabsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxabsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxabsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxabsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxabsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_UpperReal_Fujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_LowerReal_Fujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.bounds_UpperReal_Fujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.bounds_UpperReal_Fujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.bounds_LowerReal_Fujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.bounds_LowerReal_Fujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.bounds_Real_Laguerre();\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_zeroSmallCoefs() {\n        const c = this.coefs;\n        const ERRF = 1e-15;\n        const err = 10 * ERRF * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_toMonic() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divide_scalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {number}\n     */\n    bound_UpperAbs_Rouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {number}\n     */\n    bound_LowerAbs_Rouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    bounds_Real_Laguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRoots_Descartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n}\n\nPolynomial.TOLERANCE = 1e-6;\nPolynomial.ACCURACY = 15;\n\nexport default Polynomial;\n","/**\n *  SqrtPolynomial.js\n *\n *  @module SqrtPolynomial\n *  @copyright 2002-2019 Kevin Lindsey\n */\n\nimport Polynomial from \"./Polynomial.js\";\n\n\n/**\n *  SqrtPolynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass SqrtPolynomial extends Polynomial {\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     *  @returns {number}\n     */\n    eval(x) {\n        const TOLERANCE = 1e-7;\n\n        let result = super.eval(x);\n\n        // NOTE: May need to change the following.  I added these to capture\n        // some really small negative values that were being generated by one\n        // of my Bezier arcLength functions\n        if (Math.abs(result) < TOLERANCE) {\n            result = 0;\n        }\n\n        if (result < 0) {\n            throw new Error(\"SqrtPolynomial.eval: cannot take square root of negative number\");\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const result = super.toString();\n\n        return \"sqrt(\" + result + \")\";\n    }\n}\n\nexport default SqrtPolynomial;\n"],"names":["sign","x","NaN","Polynomial","coefs","i","arguments","length","push","_variable","_s","poly","this","slice","isNaN","Error","result","that","d1","getDegree","d2","dmax","Math","max","v1","v2","j","scalar","TOLERANCE","undefined","abs","pop","min","minValue","eval","maxValue","tmp1","log","tmp2","LN10","ACCURACY","iters","ceil","LN2","value","signs","round","signString","n","range","iter","delta","sum","st","t","s","os","ost","Array","MAX","h","y","dy","trapezoid","interpolate","derivative","simplify","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","roots","bisection","droots","getDerivative","getRootsInInterval","a","results","b","d","e","sqrt","c3","c2","c1","offset","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","pow","distance","angle","atan2","cos","sin","sqrt3","divide_scalar","poly_d","derrt","getRoots","sort","dery","nr","rb","bounds","maxabsX","minX","maxX","dx","guesses","minmax","f","df","newton_secant_bisection","concat","an","reduce","m","v","nm","map","coefSelectionFunc","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","reverse","res","bounds_UpperReal_Fujiwara","urb","bounds_LowerReal_Fujiwara","c","err","pv","cv","prev","curr","p1","undersqrt","p2","accum","ai","prev_a","pos","neg","maxRealPos","maxRealNeg","minComplex","xs","ys","constructor","ns","diff","dift","ho","hp","w","den","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","SqrtPolynomial"],"mappings":"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"}